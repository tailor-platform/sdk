import * as fs from "node:fs";
import { createRequire } from "node:module";
import * as path from "node:path";
import { styleText } from "node:util";
import ml from "multiline-ts";
import type { AppConfig } from "@/configure/config";

export interface AttributeMapConfig {
  [key: string]: string;
}

export type AttributeListConfig = readonly string[];

interface ExtractedAttributes {
  attributeMap?: AttributeMapConfig;
  attributeList?: AttributeListConfig;
  env?: Record<string, string | number | boolean>;
}

function extractAttributesFromConfig(config: AppConfig): ExtractedAttributes {
  return collectAttributesFromConfig(config);
}

export function generateTypeDefinition(
  attributeMap: AttributeMapConfig | undefined,
  attributeList: AttributeListConfig | undefined,
  env?: Record<string, string | number | boolean>,
): string {
  // Generate AttributeMap interface
  // attributeMap values are type string representations (e.g., "string", "boolean", "string[]")
  const mapFields = attributeMap
    ? Object.entries(attributeMap)
        .map(([key, value]) => `      ${key}: ${value};`)
        .join("\n")
    : "";

  const mapBody =
    !attributeMap || Object.keys(attributeMap).length === 0
      ? "{}"
      : `{
${mapFields}
    }`;

  // Generate AttributeList type as a tuple of strings based on the length
  const listType = attributeList
    ? `[${attributeList.map(() => "string").join(", ")}]`
    : "[]";

  // Use interface with __tuple marker for declaration merging and tuple type support
  const listBody = `{
      __tuple?: ${listType};
    }`;

  // Generate Env interface
  const envFields = env
    ? Object.entries(env)
        .map(([key, value]) => {
          const valueType =
            typeof value === "string" ? `"${value}"` : String(value);
          return `      ${key}: ${valueType};`;
        })
        .join("\n")
    : "";

  const envBody =
    !env || Object.keys(env).length === 0
      ? "{}"
      : `{
${envFields}
    }`;

  return ml /* ts */ `
// This file is auto-generated by @tailor-platform/sdk
// Do not edit this file manually
// Regenerated automatically when running 'tailor-sdk apply' or 'tailor-sdk generate'

declare global {
  namespace TailorSDK {
    interface AttributeMap ${mapBody}
    interface AttributeList ${listBody}
    interface Env ${envBody}
  }
}

export {};

`;
}

const require = createRequire(import.meta.url);

function collectAttributesFromConfig(config: AppConfig): ExtractedAttributes {
  const auth = config.auth;
  if (!auth || typeof auth !== "object") {
    return {};
  }

  // Check if auth has userProfile with attributes/attributeList
  if ("userProfile" in auth) {
    const userProfile = (
      auth as {
        userProfile?: {
          type?: {
            fields?: Record<
              string,
              {
                type: string;
                metadata?: {
                  array?: boolean;
                  allowedValues?: Array<{ value: string }>;
                };
              }
            >;
          };
          attributes?: Record<string, true>;
          attributeList?: AttributeListConfig;
        };
      }
    ).userProfile;

    const attributes = userProfile?.attributes;
    const fields = userProfile?.type?.fields;
    const attributeList = userProfile?.attributeList;

    // Convert attributes to AttributeMapConfig by inferring types from field metadata
    const attributeMap: AttributeMapConfig | undefined = attributes
      ? Object.keys(attributes).reduce((acc, key) => {
          const { type, metadata } = fields?.[key] ?? {};

          // Default to string if no metadata
          if (!metadata) {
            acc[key] = "string";
            return acc;
          }

          let typeStr = "string";

          if (type === "boolean") {
            typeStr = "boolean";
          } else if (type === "enum" && metadata.allowedValues) {
            // Generate union type from enum values
            typeStr = metadata.allowedValues
              .map((v) => `"${v.value}"`)
              .join(" | ");
          }

          // Add array suffix if needed
          if (metadata.array) {
            typeStr += "[]";
          }

          acc[key] = typeStr;
          return acc;
        }, {} as AttributeMapConfig)
      : undefined;

    return {
      attributeMap,
      attributeList,
    };
  }

  return {};
}

export function resolveTypeDefinitionPath(configPath: string): string {
  const configDir = path.dirname(path.resolve(configPath));
  const packageDir = resolvePackageDirectory(configDir);

  if (!packageDir) {
    return path.join(
      configDir,
      "node_modules",
      "@tailor-platform",
      "sdk",
      "dist",
      "plugin-generated.d.ts",
    );
  }

  return path.join(packageDir, "dist", "plugin-generated.d.ts");
}

export async function generateUserTypes(
  config: AppConfig,
  configPath: string,
): Promise<void> {
  try {
    const { attributeMap, attributeList } = extractAttributesFromConfig(config);
    if (!attributeMap && !attributeList) {
      console.log(styleText("cyan", "No attributes found in configuration"));
      return;
    }

    if (attributeMap) {
      console.log("Extracted AttributeMap:", attributeMap);
    }
    if (attributeList) {
      console.log("Extracted AttributeList:", attributeList);
    }

    const env = config.env;
    if (env) {
      console.log("Extracted Env:", env);
    }

    // Generate type definition
    const typeDefContent = generateTypeDefinition(
      attributeMap,
      attributeList,
      env,
    );
    const outputPath = resolveTypeDefinitionPath(configPath);

    // Write to file
    fs.mkdirSync(path.dirname(outputPath), { recursive: true });
    fs.writeFileSync(outputPath, typeDefContent);
    const relativePath = path.relative(process.cwd(), outputPath);
    console.log("");
    console.log(
      "Generated type definitions:",
      styleText("green", relativePath),
    );
  } catch (error) {
    console.error(styleText("red", "Error generating types"));
    console.error(error);
    // Don't throw - this should not block apply/generate
  }
}

function resolvePackageDirectory(startDir: string): string | null {
  let currentDir = startDir;
  const root = path.parse(currentDir).root;

  while (true) {
    const candidate = path.join(
      currentDir,
      "node_modules",
      "@tailor-platform",
      "sdk",
    );
    const packageJsonPath = path.join(candidate, "package.json");
    if (fs.existsSync(packageJsonPath)) {
      return candidate;
    }

    if (currentDir === root) {
      break;
    }

    const parentDir = path.dirname(currentDir);
    currentDir = parentDir;
  }

  try {
    const resolved = require.resolve("@tailor-platform/sdk/package.json", {
      paths: [startDir],
    });
    return path.dirname(resolved);
  } catch {
    return null;
  }
}
