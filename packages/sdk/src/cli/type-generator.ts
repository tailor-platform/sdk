import * as fs from "node:fs";
import { createRequire } from "node:module";
import ml from "multiline-ts";
import * as path from "pathe";
import { logger } from "@/cli/utils/logger";
import type { AppConfig } from "@/configure/config";

export interface AttributeMapConfig {
  [key: string]: string;
}

export type AttributeListConfig = readonly string[];

interface ExtractedAttributes {
  attributeMap?: AttributeMapConfig;
  attributeList?: AttributeListConfig;
  env?: Record<string, string | number | boolean>;
}

function extractAttributesFromConfig(config: AppConfig): ExtractedAttributes {
  return collectAttributesFromConfig(config);
}

/**
 * Generate the contents of the user-defined type definition file.
 * @param attributeMap - Attribute map configuration
 * @param attributeList - Attribute list configuration
 * @param [env] - Environment configuration
 * @returns Generated type definition source
 */
export function generateTypeDefinition(
  attributeMap: AttributeMapConfig | undefined,
  attributeList: AttributeListConfig | undefined,
  env?: Record<string, string | number | boolean>,
): string {
  // Generate AttributeMap interface
  // attributeMap values are type string representations (e.g., "string", "boolean", "string[]")
  const mapFields = attributeMap
    ? Object.entries(attributeMap)
        .map(([key, value]) => `    ${key}: ${value};`)
        .join("\n")
    : "";

  const mapBody =
    !attributeMap || Object.keys(attributeMap).length === 0
      ? "{}"
      : `{
${mapFields}
  }`;

  // Generate AttributeList type as a tuple of strings based on the length
  const listType = attributeList ? `[${attributeList.map(() => "string").join(", ")}]` : "[]";

  // Use interface with __tuple marker for declaration merging and tuple type support
  const listBody = `{
    __tuple?: ${listType};
  }`;

  // Generate Env interface
  const envFields = env
    ? Object.entries(env)
        .map(([key, value]) => {
          const valueType = typeof value === "string" ? `"${value}"` : String(value);
          return `    ${key}: ${valueType};`;
        })
        .join("\n")
    : "";

  const envBody =
    !env || Object.keys(env).length === 0
      ? "{}"
      : `{
${envFields}
  }`;

  return ml /* ts */ `
/* eslint-disable @typescript-eslint/no-empty-object-type */
// This file is auto-generated by @tailor-platform/sdk
// Do not edit this file manually
// Regenerated automatically when running 'tailor-sdk apply' or 'tailor-sdk generate'

declare module "@tailor-platform/sdk" {
  interface AttributeMap ${mapBody}
  interface AttributeList ${listBody}
  interface Env ${envBody}
}

export {};

`;
}

const require = createRequire(import.meta.url);

function collectAttributesFromConfig(config: AppConfig): ExtractedAttributes {
  const auth = config.auth;
  if (!auth || typeof auth !== "object") {
    return {};
  }

  // Check if auth has userProfile with attributes/attributeList
  if ("userProfile" in auth) {
    const userProfile = (
      auth as {
        userProfile?: {
          type?: {
            fields?: Record<
              string,
              {
                type: string;
                metadata?: {
                  array?: boolean;
                  allowedValues?: Array<{ value: string }>;
                };
              }
            >;
          };
          attributes?: Record<string, true>;
          attributeList?: AttributeListConfig;
        };
      }
    ).userProfile;

    const attributes = userProfile?.attributes;
    const fields = userProfile?.type?.fields;
    const attributeList = userProfile?.attributeList;

    // Convert attributes to AttributeMapConfig by inferring types from field metadata
    const attributeMap: AttributeMapConfig | undefined = attributes
      ? Object.keys(attributes).reduce((acc, key) => {
          const { type, metadata } = fields?.[key] ?? {};

          // Default to string if no metadata
          if (!metadata) {
            acc[key] = "string";
            return acc;
          }

          let typeStr = "string";

          if (type === "boolean") {
            typeStr = "boolean";
          } else if (type === "enum" && metadata.allowedValues) {
            // Generate union type from enum values
            typeStr = metadata.allowedValues.map((v) => `"${v.value}"`).join(" | ");
          }

          // Add array suffix if needed
          if (metadata.array) {
            typeStr += "[]";
          }

          acc[key] = typeStr;
          return acc;
        }, {} as AttributeMapConfig)
      : undefined;

    return {
      attributeMap,
      attributeList,
    };
  }

  return {};
}

/**
 * Resolve the output path for the generated type definition file.
 * @param configPath - Path to Tailor config file
 * @returns Absolute path to the type definition file
 */
function resolveTypeDefinitionPath(configPath: string): string {
  // Check for environment variable override
  const typePath = process.env.TAILOR_PLATFORM_SDK_TYPE_PATH;
  if (typePath) {
    return path.resolve(process.cwd(), typePath);
  }

  const configDir = path.dirname(path.resolve(configPath));
  const packageDir = resolvePackageDirectory(configDir);

  if (!packageDir) {
    return path.join(
      configDir,
      "node_modules",
      "@tailor-platform",
      "sdk",
      "dist",
      "user-defined.d.ts",
    );
  }

  return path.join(packageDir, "dist", "user-defined.d.ts");
}

/**
 * Generate user type definitions from the app config and write them to disk.
 * @param config - Application config
 * @param configPath - Path to Tailor config file
 * @returns Promise that resolves when types are generated
 */
export async function generateUserTypes(config: AppConfig, configPath: string): Promise<void> {
  try {
    const { attributeMap, attributeList } = extractAttributesFromConfig(config);
    if (!attributeMap && !attributeList) {
      logger.info("No attributes found in configuration", { mode: "plain" });
    }

    if (attributeMap) {
      logger.debug(`Extracted AttributeMap: ${JSON.stringify(attributeMap)}`);
    }
    if (attributeList) {
      logger.debug(`Extracted AttributeList: ${JSON.stringify(attributeList)}`);
    }

    const env = config.env;
    if (env) {
      logger.debug(`Extracted Env: ${JSON.stringify(env)}`);
    }

    // Generate type definition
    const typeDefContent = generateTypeDefinition(attributeMap, attributeList, env);
    const outputPath = resolveTypeDefinitionPath(configPath);

    // Write to file
    fs.mkdirSync(path.dirname(outputPath), { recursive: true });
    fs.writeFileSync(outputPath, typeDefContent);
    const relativePath = path.relative(process.cwd(), outputPath);
    logger.newline();
    logger.success(`Generated type definitions: ${relativePath}`, {
      mode: "plain",
    });
  } catch (error) {
    logger.error("Error generating types");
    logger.error(String(error));
    // Don't throw - this should not block apply/generate
  }
}

function resolvePackageDirectory(startDir: string): string | null {
  let currentDir = startDir;
  const root = path.parse(currentDir).root;

  while (true) {
    const candidate = path.join(currentDir, "node_modules", "@tailor-platform", "sdk");
    const packageJsonPath = path.join(candidate, "package.json");
    if (fs.existsSync(packageJsonPath)) {
      return candidate;
    }

    if (currentDir === root) {
      break;
    }

    const parentDir = path.dirname(currentDir);
    currentDir = parentDir;
  }

  try {
    const resolved = require.resolve("@tailor-platform/sdk/package.json", {
      paths: [startDir],
    });
    return path.dirname(resolved);
  } catch {
    return null;
  }
}
