import * as fs from "node:fs";
import { createRequire } from "node:module";
import ml from "multiline-ts";
import * as path from "pathe";
import { logger } from "@/cli/utils/logger";
// eslint-disable-next-line import/order -- type imports are excluded from pathGroups, causing false positive
import type { AppConfig } from "@/configure/config";
import type { TailorAnyField } from "@/configure/types";
import type {
  ParsedTailorDBType,
  TypeSourceInfo,
  OperatorFieldConfig,
} from "@/parser/service/tailordb";

export interface AttributeMapConfig {
  [key: string]: string;
}

export type AttributeListConfig = readonly string[];

interface ExtractedAttributes {
  attributeMap?: AttributeMapConfig;
  attributeList?: AttributeListConfig;
  env?: Record<string, string | number | boolean>;
}

function extractAttributesFromConfig(config: AppConfig): ExtractedAttributes {
  return collectAttributesFromConfig(config);
}

/**
 * Generate the contents of the user-defined type definition file.
 * @param attributeMap - Attribute map configuration
 * @param attributeList - Attribute list configuration
 * @param env - Environment configuration
 * @returns Generated type definition source
 */
export function generateTypeDefinition(
  attributeMap: AttributeMapConfig | undefined,
  attributeList: AttributeListConfig | undefined,
  env?: Record<string, string | number | boolean>,
): string {
  // Generate AttributeMap interface
  // attributeMap values are type string representations (e.g., "string", "boolean", "string[]")
  const mapFields = attributeMap
    ? Object.entries(attributeMap)
        .map(([key, value]) => `    ${key}: ${value};`)
        .join("\n")
    : "";

  const mapBody =
    !attributeMap || Object.keys(attributeMap).length === 0
      ? "{}"
      : `{
${mapFields}
  }`;

  // Generate AttributeList type as a tuple of strings based on the length
  const listType = attributeList ? `[${attributeList.map(() => "string").join(", ")}]` : "[]";

  // Use interface with __tuple marker for declaration merging and tuple type support
  const listBody = `{
    __tuple?: ${listType};
  }`;

  // Generate Env interface
  const envFields = env
    ? Object.entries(env)
        .map(([key, value]) => {
          const valueType = typeof value === "string" ? `"${value}"` : String(value);
          return `    ${key}: ${valueType};`;
        })
        .join("\n")
    : "";

  const envBody =
    !env || Object.keys(env).length === 0
      ? "{}"
      : `{
${envFields}
  }`;

  return ml /* ts */ `
/* eslint-disable @typescript-eslint/no-empty-object-type */
// This file is auto-generated by @tailor-platform/sdk
// Do not edit this file manually
// Regenerated automatically when running 'tailor-sdk apply' or 'tailor-sdk generate'

declare module "@tailor-platform/sdk" {
  interface AttributeMap ${mapBody}
  interface AttributeList ${listBody}
  interface Env ${envBody}
}

export {};

`;
}

const require = createRequire(import.meta.url);

function collectAttributesFromConfig(config: AppConfig): ExtractedAttributes {
  const auth = config.auth;
  if (!auth || typeof auth !== "object") {
    return {};
  }

  // Check if auth has userProfile with attributes/attributeList
  if ("userProfile" in auth) {
    const userProfile = (
      auth as {
        userProfile?: {
          type?: {
            fields?: Record<
              string,
              {
                type: string;
                metadata?: {
                  array?: boolean;
                  allowedValues?: Array<{ value: string }>;
                };
              }
            >;
          };
          attributes?: Record<string, true>;
          attributeList?: AttributeListConfig;
        };
      }
    ).userProfile;

    const attributes = userProfile?.attributes;
    const fields = userProfile?.type?.fields;
    const attributeList = userProfile?.attributeList;

    // Convert attributes to AttributeMapConfig by inferring types from field metadata
    const attributeMap: AttributeMapConfig | undefined = attributes
      ? Object.keys(attributes).reduce((acc, key) => {
          const { type, metadata } = fields?.[key] ?? {};

          // Default to string if no metadata
          if (!metadata) {
            acc[key] = "string";
            return acc;
          }

          let typeStr = "string";

          if (type === "boolean") {
            typeStr = "boolean";
          } else if (type === "enum" && metadata.allowedValues) {
            // Generate union type from enum values
            typeStr = metadata.allowedValues.map((v) => `"${v.value}"`).join(" | ");
          }

          // Add array suffix if needed
          if (metadata.array) {
            typeStr += "[]";
          }

          acc[key] = typeStr;
          return acc;
        }, {} as AttributeMapConfig)
      : undefined;

    return {
      attributeMap,
      attributeList,
    };
  }

  return {};
}

/**
 * Resolve the output path for the generated type definition file.
 * @param configPath - Path to Tailor config file
 * @returns Absolute path to the type definition file
 */
function resolveTypeDefinitionPath(configPath: string): string {
  // Check for environment variable override
  const typePath = process.env.TAILOR_PLATFORM_SDK_TYPE_PATH;
  if (typePath) {
    return path.resolve(process.cwd(), typePath);
  }

  const configDir = path.dirname(path.resolve(configPath));
  const packageDir = resolvePackageDirectory(configDir);

  if (!packageDir) {
    return path.join(
      configDir,
      "node_modules",
      "@tailor-platform",
      "sdk",
      "dist",
      "user-defined.d.ts",
    );
  }

  return path.join(packageDir, "dist", "user-defined.d.ts");
}

/**
 * Generate user type definitions from the app config and write them to disk.
 * @param config - Application config
 * @param configPath - Path to Tailor config file
 * @returns Promise that resolves when types are generated
 */
export async function generateUserTypes(config: AppConfig, configPath: string): Promise<void> {
  try {
    const { attributeMap, attributeList } = extractAttributesFromConfig(config);
    if (!attributeMap && !attributeList) {
      logger.info("No attributes found in configuration", { mode: "plain" });
    }

    if (attributeMap) {
      logger.debug(`Extracted AttributeMap: ${JSON.stringify(attributeMap)}`);
    }
    if (attributeList) {
      logger.debug(`Extracted AttributeList: ${JSON.stringify(attributeList)}`);
    }

    const env = config.env;
    if (env) {
      logger.debug(`Extracted Env: ${JSON.stringify(env)}`);
    }

    // Generate type definition
    const typeDefContent = generateTypeDefinition(attributeMap, attributeList, env);
    const outputPath = resolveTypeDefinitionPath(configPath);

    // Write to file
    fs.mkdirSync(path.dirname(outputPath), { recursive: true });
    fs.writeFileSync(outputPath, typeDefContent);
    const relativePath = path.relative(process.cwd(), outputPath);
    logger.newline();
    logger.success(`Generated type definitions: ${relativePath}`, {
      mode: "plain",
    });
  } catch (error) {
    logger.error("Error generating types");
    logger.error(String(error));
    // Don't throw - this should not block apply/generate
  }
}

/**
 * Plugin info for type generation
 */
export interface PluginInfo {
  id: string;
  configSchema: TailorAnyField;
}

/**
 * Field metadata structure from TailorField
 */
interface FieldMetadata {
  required?: boolean;
  array?: boolean;
  allowedValues?: Array<{ value: string }>;
}

/**
 * Convert a TailorField type to its TypeScript type string.
 * @param fieldType - The field type (string, number, etc.)
 * @param metadata - Field metadata
 * @param nestedFields - Nested fields for object types
 * @param indent - Indentation level
 * @returns TypeScript type string
 */
function fieldTypeToString(
  fieldType: string,
  metadata: FieldMetadata,
  nestedFields?: Record<string, TailorAnyField>,
  indent = 0,
): string {
  const innerPadding = "  ".repeat(indent + 1);
  const padding = "  ".repeat(indent);

  let baseType: string;

  switch (fieldType) {
    case "string":
    case "uuid":
    case "date":
    case "datetime":
    case "time":
      baseType = "string";
      break;
    case "integer":
    case "float":
    case "number":
      baseType = "number";
      break;
    case "boolean":
      baseType = "boolean";
      break;
    case "enum":
      if (metadata.allowedValues && metadata.allowedValues.length > 0) {
        baseType = metadata.allowedValues.map((v) => `"${v.value}"`).join(" | ");
      } else {
        baseType = "string";
      }
      break;
    case "nested":
    case "object":
      if (nestedFields && Object.keys(nestedFields).length > 0) {
        const fields = Object.entries(nestedFields)
          .map(([key, field]) => {
            const fm = field.metadata as FieldMetadata;
            const isOptional = fm.required === false;
            const typeStr = fieldTypeToString(field.type, fm, field.fields, indent + 1);
            return `${innerPadding}${key}${isOptional ? "?" : ""}: ${typeStr};`;
          })
          .join("\n");
        baseType = `{\n${fields}\n${padding}}`;
      } else {
        baseType = "Record<string, unknown>";
      }
      break;
    default:
      baseType = "unknown";
  }

  // Handle array types
  if (metadata.array) {
    return `${baseType}[]`;
  }

  return baseType;
}

/**
 * Convert a plugin config schema to a TypeScript type string.
 * @param schema - TailorField definition for the config
 * @param indent - Base indentation level
 * @returns TypeScript type string
 */
function configSchemaToTypeString(schema: TailorAnyField, indent = 2): string {
  const metadata = schema.metadata as FieldMetadata;

  // For nested (object) types, generate object type
  if (schema.type === "nested" && schema.fields) {
    const innerPadding = "  ".repeat(indent + 1);
    const padding = "  ".repeat(indent);

    const entries = Object.entries(schema.fields);
    if (entries.length === 0) {
      return "{}";
    }

    const fields = entries
      .map(([key, field]) => {
        const fieldMetadata = field.metadata as FieldMetadata;
        const isOptional = fieldMetadata.required === false;
        const typeStr = fieldTypeToString(field.type, fieldMetadata, field.fields, indent + 1);
        return `${innerPadding}${key}${isOptional ? "?" : ""}: ${typeStr};`;
      })
      .join("\n");

    return `{\n${fields}\n${padding}}`;
  }

  // For non-nested types, generate the type directly
  return fieldTypeToString(schema.type, metadata, schema.fields, indent);
}

/**
 * Generate the contents of the plugin-defined type definition file.
 * @param plugins - Array of plugin info objects
 * @returns Generated type definition source
 */
function generatePluginTypeDefinition(plugins: PluginInfo[]): string {
  if (plugins.length === 0) {
    return ml /* ts */ `
/* eslint-disable @typescript-eslint/no-empty-object-type */
// This file is auto-generated by @tailor-platform/sdk
// Do not edit this file manually
// Regenerated automatically when running 'tailor-sdk generate'

// No plugins are registered. Add plugins using definePlugins() in tailor.config.ts
// to generate type definitions here.

declare module "@tailor-platform/sdk" {
  interface PluginConfigs {}
}

export {};

`;
  }

  // Generate config types for each plugin from their schemas
  const pluginEntries = plugins
    .map((plugin) => {
      const typeStr = plugin.configSchema
        ? configSchemaToTypeString(plugin.configSchema, 2)
        : "Record<string, unknown>";
      return `    "${plugin.id}": ${typeStr};`;
    })
    .join("\n");

  return ml /* ts */ `
/* eslint-disable @typescript-eslint/no-empty-object-type */
// This file is auto-generated by @tailor-platform/sdk
// Do not edit this file manually
// Regenerated automatically when running 'tailor-sdk generate'

declare module "@tailor-platform/sdk" {
  interface PluginConfigs {
${pluginEntries}
  }
}

export {};

`;
}

/**
 * Resolve the output path for the plugin type definition file.
 * @param configPath - Path to Tailor config file
 * @returns Absolute path to the plugin type definition file
 */
function resolvePluginTypeDefinitionPath(configPath: string): string {
  const configDir = path.dirname(path.resolve(configPath));
  const packageDir = resolvePackageDirectory(configDir);

  if (!packageDir) {
    return path.join(
      configDir,
      "node_modules",
      "@tailor-platform",
      "sdk",
      "dist",
      "plugin-defined.d.ts",
    );
  }

  return path.join(packageDir, "dist", "plugin-defined.d.ts");
}

/**
 * Generate plugin type definitions and write them to disk.
 * @param plugins - Array of plugin info objects
 * @param configPath - Path to Tailor config file
 * @returns Promise that resolves when types are generated
 */
export async function generatePluginTypes(
  plugins: PluginInfo[],
  configPath: string,
): Promise<void> {
  try {
    if (plugins.length === 0) {
      logger.debug("No plugins registered, generating empty plugin-defined.d.ts");
    } else {
      logger.debug(`Generating plugin types for: ${plugins.map((p) => p.id).join(", ")}`);
    }

    const typeDefContent = generatePluginTypeDefinition(plugins);
    const outputPath = resolvePluginTypeDefinitionPath(configPath);

    fs.mkdirSync(path.dirname(outputPath), { recursive: true });
    fs.writeFileSync(outputPath, typeDefContent);
    const relativePath = path.relative(process.cwd(), outputPath);
    logger.success(`Generated plugin type definitions: ${relativePath}`, {
      mode: "plain",
    });
  } catch (error) {
    logger.error("Error generating plugin types");
    logger.error(String(error));
  }
}

function resolvePackageDirectory(startDir: string): string | null {
  let currentDir = startDir;
  const root = path.parse(currentDir).root;

  while (true) {
    const candidate = path.join(currentDir, "node_modules", "@tailor-platform", "sdk");
    const packageJsonPath = path.join(candidate, "package.json");
    if (fs.existsSync(packageJsonPath)) {
      return candidate;
    }

    if (currentDir === root) {
      break;
    }

    const parentDir = path.dirname(currentDir);
    currentDir = parentDir;
  }

  try {
    const resolved = require.resolve("@tailor-platform/sdk/package.json", {
      paths: [startDir],
    });
    return path.dirname(resolved);
  } catch {
    return null;
  }
}

// --- Plugin-generated TailorDB type file generation ---

/**
 * Generated file information for plugin-generated types
 */
export interface GeneratedTypeFile {
  /** Absolute file path */
  path: string;
  /** File content */
  content: string;
}

/**
 * Input data for plugin type file generation
 */
export interface PluginTypeGenerationInput {
  /** Namespace name (e.g., "tailordb") */
  namespace: string;
  /** Parsed TailorDB types */
  types: Record<string, ParsedTailorDBType>;
  /** Type source information */
  sourceInfo: TypeSourceInfo;
}

/**
 * Convert a field type to its db.* method call string.
 * @param fieldConfig - Field configuration
 * @returns db.* method call string (e.g., "db.string()", "db.uuid({ optional: true })")
 */
function fieldConfigToDbCall(fieldConfig: OperatorFieldConfig): string {
  // Determine if the field is optional (not required means optional)
  const isOptional = !fieldConfig.required;
  const isArray = fieldConfig.array;

  // Build options object for the db.* method call
  const buildOptions = (): string => {
    const opts: string[] = [];
    if (isOptional) opts.push("optional: true");
    if (isArray) opts.push("array: true");
    return opts.length > 0 ? `{ ${opts.join(", ")} }` : "";
  };

  let baseCall: string;
  const options = buildOptions();

  // Map field type to db method
  switch (fieldConfig.type) {
    case "string":
      baseCall = options ? `db.string(${options})` : "db.string()";
      break;
    case "uuid":
      baseCall = options ? `db.uuid(${options})` : "db.uuid()";
      break;
    case "integer":
      baseCall = options ? `db.int(${options})` : "db.int()";
      break;
    case "float":
      baseCall = options ? `db.float(${options})` : "db.float()";
      break;
    case "boolean":
      baseCall = options ? `db.bool(${options})` : "db.bool()";
      break;
    case "date":
      baseCall = options ? `db.date(${options})` : "db.date()";
      break;
    case "datetime":
      baseCall = options ? `db.datetime(${options})` : "db.datetime()";
      break;
    case "time":
      baseCall = options ? `db.time(${options})` : "db.time()";
      break;
    case "enum":
      if (fieldConfig.allowedValues && fieldConfig.allowedValues.length > 0) {
        const values = fieldConfig.allowedValues.map((v) => {
          if (v.description) {
            return `{ value: "${v.value}", description: "${v.description}" }`;
          }
          return `"${v.value}"`;
        });
        baseCall = `db.enum([${values.join(", ")}]${options ? `, ${options}` : ""})`;
      } else {
        baseCall = `db.enum([]${options ? `, ${options}` : ""})`;
      }
      break;
    case "nested":
      if (fieldConfig.fields && Object.keys(fieldConfig.fields).length > 0) {
        const nestedFields = Object.entries(fieldConfig.fields)
          .map(([name, config]) => `    ${name}: ${fieldConfigToDbCall(config)},`)
          .join("\n");
        baseCall = `db.nested({\n${nestedFields}\n  }${options ? `, ${options}` : ""})`;
      } else {
        baseCall = `db.nested({}${options ? `, ${options}` : ""})`;
      }
      break;
    default:
      // For unknown types, use string as fallback
      baseCall = options ? `db.string(${options})` : "db.string()";
  }

  // Apply chain modifiers (index, unique, description, foreignKey)
  const modifiers: string[] = [];

  if (fieldConfig.description) {
    modifiers.push(`.description("${fieldConfig.description.replace(/"/g, '\\"')}")`);
  }

  if (fieldConfig.index) {
    modifiers.push(".index()");
  }

  if (fieldConfig.unique) {
    modifiers.push(".unique()");
  }

  if (fieldConfig.foreignKey && fieldConfig.foreignKeyType) {
    modifiers.push(`.foreignKey("${fieldConfig.foreignKeyType}")`);
  }

  return baseCall + modifiers.join("");
}

/**
 * Generate TypeScript source content for a plugin-generated TailorDB type.
 * @param type - Parsed TailorDB type
 * @returns TypeScript source code
 */
function generatePluginTypeSource(type: ParsedTailorDBType): string {
  // Generate field definitions, excluding 'id' since db.type() adds it automatically
  const fieldEntries = Object.entries(type.fields)
    .filter(([name]) => name !== "id")
    .map(([name, field]) => `  ${name}: ${fieldConfigToDbCall(field.config)},`)
    .join("\n");

  // Check if we need to add timestamps
  const hasCreatedAt = "createdAt" in type.fields;
  const hasUpdatedAt = "updatedAt" in type.fields;
  const hasTimestamps = hasCreatedAt && hasUpdatedAt;

  // Filter out timestamp fields if they exist
  const nonTimestampFields = Object.entries(type.fields)
    .filter(([name]) => name !== "id" && name !== "createdAt" && name !== "updatedAt")
    .map(([name, field]) => `  ${name}: ${fieldConfigToDbCall(field.config)},`)
    .join("\n");

  const fieldsContent = hasTimestamps
    ? `${nonTimestampFields}\n  ...db.fields.timestamps(),`
    : fieldEntries;

  return ml /* ts */ `
// This file is auto-generated by @tailor-platform/sdk
// Do not edit this file manually
// Generated for plugin-created type: ${type.name}

import { db } from "@tailor-platform/sdk";

export const ${type.name} = db.type("${type.name}", {
${fieldsContent}
});

export type ${type.name} = typeof ${type.name};

`;
}

/**
 * Generate TypeScript files for plugin-generated TailorDB types.
 * @param inputs - Array of namespace data with types and sourceInfo
 * @returns Array of generated file information
 */
export function generatePluginTypeFiles(inputs: PluginTypeGenerationInput[]): GeneratedTypeFile[] {
  const files: GeneratedTypeFile[] = [];

  for (const { types, sourceInfo } of inputs) {
    for (const [typeName, type] of Object.entries(types)) {
      const info = sourceInfo[typeName];

      // Only generate files for plugin-generated types
      if (!info?.pluginId) {
        continue;
      }

      const content = generatePluginTypeSource(type);
      files.push({
        path: info.filePath,
        content,
      });
    }
  }

  return files;
}

/**
 * Write plugin-generated type files to disk.
 * @param files - Array of generated file information
 */
export function writePluginTypeFiles(files: GeneratedTypeFile[]): void {
  for (const file of files) {
    fs.mkdirSync(path.dirname(file.path), { recursive: true });
    fs.writeFileSync(file.path, file.content);
    const relativePath = path.relative(process.cwd(), file.path);
    logger.debug(`Generated plugin type file: ${relativePath}`);
  }

  if (files.length > 0) {
    logger.success(`Generated ${files.length} plugin type file(s) in .tailor-sdk/types/`, {
      mode: "plain",
    });
  }
}
