import type { ParsedTailorDBType } from "@/parser/service/tailordb/types";

/**
 * Interface for plugin configuration mapping.
 * Extend this interface via declaration merging to add typed plugin configs.
 *
 * @example
 * ```typescript
 * // In your plugin package or types file:
 * declare module "@tailor-platform/sdk" {
 *   interface PluginConfigs {
 *     "@my-company/audit-log": {
 *       trackedFields: string[];
 *       retentionDays?: number;
 *     };
 *   }
 * }
 * ```
 */
// eslint-disable-next-line @typescript-eslint/no-empty-object-type
export interface PluginConfigs {}

/**
 * Plugin attachment stored on TailorDBType instances.
 * This is the configuration passed via `.plugin()` method.
 */
export interface PluginAttachment {
  pluginId: string;
  config: unknown;
}

/**
 * Context passed to plugin's process method
 */
export interface PluginProcessContext {
  /** The parsed TailorDB type being processed */
  type: ParsedTailorDBType;
  /** Plugin-specific configuration passed via .plugin() method */
  config: unknown;
  /** Namespace of the TailorDB type */
  namespace: string;
}

/**
 * Interface representing a TailorDB type for plugin output.
 * This interface is satisfied by db.type() instances.
 */
export interface TailorDBTypeForPlugin {
  /** The name of the type */
  readonly name: string;
  /** The field definitions */
  readonly fields: Record<string, unknown>;
}

/**
 * Type generated by a plugin - use db.type() to create these
 */
export type PluginGeneratedType = TailorDBTypeForPlugin;

/**
 * Resolver definition generated by a plugin.
 * Fields can be TailorDB field instances or raw field definitions.
 */
export interface PluginGeneratedResolver {
  name: string;
  operation: "query" | "mutation";
  inputFields?: Record<string, unknown>;
  outputFields: Record<string, unknown>;
  /** Function body code as string */
  body: string;
}

/**
 * Trigger configuration for plugin-generated executors
 */
export interface PluginTriggerConfig {
  kind: "recordCreated" | "recordUpdated" | "recordDeleted" | "schedule" | "webhook";
  /** TailorDB type name for record triggers */
  type?: string;
  /** Cron expression for schedule trigger */
  schedule?: string;
}

/**
 * Operation configuration for plugin-generated executors
 */
export interface PluginOperationConfig {
  kind: "function" | "webhook" | "graphql" | "workflow";
  /** Function body code for function operations */
  body?: string;
  /** URL for webhook operations */
  url?: string;
  /** GraphQL query for graphql operations */
  query?: string;
}

/**
 * Executor definition generated by a plugin
 */
export interface PluginGeneratedExecutor {
  name: string;
  description?: string;
  trigger: PluginTriggerConfig;
  operation: PluginOperationConfig;
}

/**
 * Output returned by a plugin's process method
 */
export interface PluginOutput {
  /** Additional TailorDB types to generate */
  types?: PluginGeneratedType[];
  /** Additional resolvers to generate */
  resolvers?: PluginGeneratedResolver[];
  /** Additional executors to generate */
  executors?: PluginGeneratedExecutor[];
}

/**
 * Base plugin interface that all plugins must implement
 */
export interface PluginBase {
  /** Unique identifier for the plugin */
  readonly id: string;
  /** Human-readable description of the plugin */
  readonly description: string;

  /**
   * Process a single TailorDB type and generate outputs
   * @param context - Context containing the type, config, and namespace
   * @returns Plugin output with generated types, resolvers, and executors
   */
  process(context: PluginProcessContext): PluginOutput | Promise<PluginOutput>;
}

/**
 * Plugin configuration input type for definePlugins()
 * Can be either a tuple [pluginId, options] for built-in plugins
 * or a PluginBase object for custom plugins
 */
export type PluginConfig = readonly [string, Record<string, unknown>] | PluginBase;
